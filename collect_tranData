INFURA_URL = "https://mainnet.infura.io/v3/bbcfbb0f72fc4a5292cd80aae6016e84"
w3 = Web3(Web3.HTTPProvider(INFURA_URL))

block_size = 2500  # æƒæçš„å€å¡Šæ•¸é‡
data_size = 5000   # ç¸½å…±è¦æ”¶é›†çš„åœ°å€æ•¸é‡
target_per_category = data_size // 4  # æ¯å€‹é¡åˆ¥çš„ç›®æ¨™æ•¸é‡

# EIP-165 ä»‹é¢ ID
ERC721_INTERFACE_ID = "0x80ac58cd"
ERC1155_INTERFACE_ID = "0xd9b67a26"

# åˆå§‹åŒ–åˆ†é¡
eoa_wallets = set()
token_contracts = set()
nft_contracts = set()
other_contracts = set()

def get_code(address):
    """å–å¾—åˆç´„ bytecode"""
    return w3.eth.get_code(address).hex()

def is_eoa(address):
    """æª¢æŸ¥æ˜¯å¦ç‚º EOAï¼ˆå¤–éƒ¨éŒ¢åŒ…ï¼‰"""
    return get_code(address) == "0x"

def supports_interface(address, interface_id):
    """æª¢æŸ¥åˆç´„æ˜¯å¦æ”¯æ´ ERC-165 ä»‹é¢ï¼ˆERC-721, ERC-1155ï¼‰"""
    try:
        contract = w3.eth.contract(address=address, abi=[{
            "constant": True,
            "inputs": [{"name": "interfaceID", "type": "bytes4"}],
            "name": "supportsInterface",
            "outputs": [{"name": "", "type": "bool"}],
            "payable": False,
            "stateMutability": "view",
            "type": "function"
        }])
        return contract.functions.supportsInterface(interface_id).call()
    except:
        return False

def is_erc20(address):
    """æª¢æŸ¥æ˜¯å¦ç‚º ERC-20 ä»£å¹£"""
    try:
        contract = w3.eth.contract(address=address, abi=[
            {"constant": True, "inputs": [], "name": "totalSupply", "outputs": [{"name": "", "type": "uint256"}], "stateMutability": "view", "type": "function"},
            {"constant": True, "inputs": [], "name": "symbol", "outputs": [{"name": "", "type": "string"}], "stateMutability": "view", "type": "function"},
            {"constant": True, "inputs": [], "name": "decimals", "outputs": [{"name": "", "type": "uint8"}], "stateMutability": "view", "type": "function"}
        ])
        return contract.functions.totalSupply().call() is not None
    except:
        return False

def print_progress():
    """å³æ™‚é¡¯ç¤ºæ”¶é›†é€²åº¦"""
    print(f"ğŸ”„ ç›®å‰é€²åº¦: EOA: {len(eoa_wallets)}/{target_per_category}, Token: {len(token_contracts)}/{target_per_category}, NFT: {len(nft_contracts)}/{target_per_category}, Other: {len(other_contracts)}/{target_per_category}")

def classify_address(address):
    """ä¾ç…§å„ªå…ˆé †åºåˆ†é¡åœ°å€"""
    if address in eoa_wallets or address in token_contracts or address in nft_contracts or address in other_contracts:
        return  # å·²åˆ†é¡éï¼Œè·³é

    # **Step 1: å…ˆåˆ†é¡ EOA**
    if len(eoa_wallets) < target_per_category:
        if is_eoa(address):
            eoa_wallets.add(address)
            print(f"âœ… EOA: {address}")
            print_progress()
            return  # EOA åˆ†é¡å®Œç•¢ï¼Œä¸å†é€²ä¸€æ­¥åˆ†é¡

    # **Step 2: EOA é”æ¨™å¾Œï¼Œåˆ†é¡ Token**
    if len(token_contracts) < target_per_category:
        if is_erc20(address):
            token_contracts.add(address)
            print(f"ğŸ’° Token: {address}")
            print_progress()
            return  # Token åˆ†é¡å®Œç•¢ï¼Œä¸å†é€²ä¸€æ­¥åˆ†é¡

    # **Step 3: Token é”æ¨™å¾Œï¼Œåˆ†é¡ NFT**
    if len(nft_contracts) < target_per_category:
        if supports_interface(address, ERC721_INTERFACE_ID) or supports_interface(address, ERC1155_INTERFACE_ID):
            nft_contracts.add(address)
            print(f"ğŸ¨ NFT: {address}")
            print_progress()
            return  # NFT åˆ†é¡å®Œç•¢ï¼Œä¸å†é€²ä¸€æ­¥åˆ†é¡

    # **Step 4: å…¶ä»–æ™ºèƒ½åˆç´„**
    if len(other_contracts) < target_per_category:
        other_contracts.add(address)
        print(f"ğŸ”§ Other Contract: {address}")
        print_progress()

def get_block_transactions(block_number):
    """å–å¾—å€å¡Šä¸­çš„äº¤æ˜“åœ°å€ï¼Œä¸¦åˆ†é¡"""
    block = w3.eth.get_block(block_number, full_transactions=True)
    addresses = set()

    for tx in block.transactions:
        try:
            # è½‰æ›ç™¼é€è€…åœ°å€ç‚º checksum æ ¼å¼
            sender = Web3.to_checksum_address(tx["from"])
            addresses.add(sender)

            # è½‰æ›æ¥æ”¶è€…åœ°å€ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            if tx.to:
                receiver = Web3.to_checksum_address(tx.to)
                addresses.add(receiver)
        except Exception as e:
            print(f"Address conversion error: {e}")
            continue  # å¿½ç•¥éŒ¯èª¤ï¼Œç¹¼çºŒè™•ç†ä¸‹ä¸€ç­†äº¤æ˜“

    for addr in addresses:
        classify_address(addr)  # ä¾åºåˆ†é¡åœ°å€


    for addr in addresses:
        classify_address(addr)  # ä¾åºåˆ†é¡åœ°å€

latest_block = w3.eth.block_number

for i in range(block_size):
    block_num = latest_block - i
    print(f'\nğŸ“Œ Scanning block {block_num}...')
    get_block_transactions(block_num)

    # æª¢æŸ¥æ˜¯å¦æ‰€æœ‰é¡åˆ¥éƒ½é”æ¨™
    if (len(eoa_wallets) >= target_per_category and
        len(token_contracts) >= target_per_category and
        len(nft_contracts) >= target_per_category and
        len(other_contracts) >= target_per_category):
        print(f"\nâœ… æ‰€æœ‰é¡åˆ¥é”æ¨™ï¼Œæå‰åœæ­¢ï¼")
        break

    time.sleep(0.1)

# å„²å­˜çµæœ
def save_addresses(filename, addresses):
    with open(filename, "w") as file:
        for addr in addresses:
            file.write(addr + "\n")
    print(f"ğŸ“‚ å·²å„²å­˜ {len(addresses)} å€‹åœ°å€åˆ° {filename}")

save_addresses("eoa_wallets.txt", eoa_wallets)
save_addresses("token_contracts.txt", token_contracts)
save_addresses("nft_contracts.txt", nft_contracts)
save_addresses("other_contracts.txt", other_contracts)

print("\nğŸ¯ åœ°å€åˆ†é¡å®Œæˆï¼")
